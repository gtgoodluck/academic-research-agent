# üéì Academic Research Agent - Complete Tutorial

## Course Overview

Welcome to this comprehensive tutorial on building an AI-powered Academic Research Agent! By the end of this course, you'll understand how to create an intelligent system that can search Google Scholar, analyze research papers, and provide insights using local AI models.

---

## üìö **Module 1: Understanding the Architecture**

### What We're Building

Our Academic Research Agent is a sophisticated AI system that combines:

- **Web Scraping** (Playwright) - To extract data from Google Scholar
- **Local AI** (Ollama Llama) - For intelligent analysis and summarization
- **Agent Framework** (LangChain) - To orchestrate tools and decision-making

### Core Components Overview

```python
class AcademicResearchAgent:
    def __init__(self):
        self.llm = Ollama(model="llama3.2", temperature=0.1)  # Our AI brain
        self.tools = self._setup_research_tools()             # Our capabilities
        self.agent = self._create_research_agent()            # Our decision maker
```

**Think of it like this:**

- **LLM** = The brain that thinks and analyzes
- **Tools** = The hands that can perform actions
- **Agent** = The coordinator that decides which tool to use when

---

## üõ†Ô∏è **Module 2: Tool Architecture - The Agent's Capabilities**

### Understanding the Tool Pattern

Each tool follows this structure:

```python
Tool(
    name="tool_name",
    description="What this tool does and when to use it",
    func=self._actual_function_that_does_the_work
)
```

### Tool 1: Scholar Search

```python
Tool(
    name="scholar_search",
    description="Search Google Scholar for papers by author name",
    func=self._search_google_scholar
)
```

**What it does:** Acts like a smart librarian that can find all papers by a specific researcher
**When it's used:** When someone asks "Find papers by Geoffrey Hinton"
**How it works:** Uses web automation to query Google Scholar and extract results

### Tool 2: Paper Analyzer

```python
Tool(
    name="paper_analyzer",
    description="Analyze and summarize a research paper from its URL",
    func=self._analyze_paper
)
```

**What it does:** Acts like a research assistant that reads papers and creates summaries
**When it's used:** When someone wants to understand a specific paper in detail
**How it works:** Scrapes paper content and uses AI to generate structured summaries

---

## üß† **Module 3: The Agent Brain - Decision Making**

### The ReAct Pattern

Our agent uses the **ReAct** (Reasoning + Acting) pattern:

```
Question: Find papers by Yann LeCun
Thought: I need to search for this author's papers
Action: scholar_search
Action Input: Yann LeCun
Observation: Found 5 papers by Yann LeCun...
Thought: Now I should present these to the user
Final Answer: Here are the papers I found...
```

### Agent Prompt Template

```python
prompt_template = """
You are an academic research assistant AI.
Available tools: {tools}
Use this format:
Question: the research question
Thought: think about the best approach
Action: the action to take
Action Input: the input to the action
Observation: the result of the action
Final Answer: Present results to user
"""
```

**Key Insight:** The agent doesn't just execute commands - it _thinks_ about what to do next based on the results it gets.

---

## üï∑Ô∏è **Module 4: Web Scraping with Playwright**

### Why Playwright?

- **Dynamic Content:** Google Scholar loads content with JavaScript
- **Reliability:** More stable than simple HTTP requests
- **Browser Automation:** Can handle complex interactions

### Core Scraping Pattern

```python
with sync_playwright() as p:
    browser = p.chromium.launch(headless=True)  # Invisible browser
    page = browser.new_page()                   # New tab
    page.goto(search_url)                       # Navigate to page
    page.wait_for_selector('.gs_rt')            # Wait for results
    results = page.query_selector_all('.gs_r')  # Extract elements
    browser.close()                             # Clean up
```

### Smart Filtering Logic

```python
# Check if paper is actually by the searched author
author_name_parts = author_name.lower().split()
name_variations = [
    author_name.lower(),                    # "geoffrey hinton"
    author_name_parts[-1],                  # "hinton"
    f"{author_name_parts[0][0]} {author_name_parts[-1]}"  # "g hinton"
]
is_relevant = any(variation in author_text_lower for variation in name_variations)
```

**Why This Matters:** Academic names can appear in many formats, so we need flexible matching.

---

## ü§ñ **Module 5: AI Integration with Ollama**

### Local AI Advantages

- **Privacy:** No data sent to external APIs
- **Cost:** Completely free to run
- **Control:** Customize the model behavior

### LLM Configuration

```python
self.llm = Ollama(
    model="llama3.2",    # Specific model version
    temperature=0.1      # Low creativity (more factual)
)
```

**Temperature Explained:**

- **0.0** = Completely deterministic, same output every time
- **0.1** = Very consistent, good for factual tasks
- **1.0** = Highly creative, good for writing tasks

### Paper Analysis Prompt

```python
summary_prompt = f"""
Analyze this research paper content and provide:
1. Main research question/problem
2. Key methodology or approach
3. Major findings/contributions
4. Significance to the field

Content: {content}
"""
```

**Prompt Engineering Tip:** Structure your prompts with clear, numbered instructions for consistent results.

---

## üîÑ **Module 6: Interactive User Experience**

### The Research Flow

```python
def research_papers_interactive(self, author_name: str):
    # Step 1: Search for papers
    papers_result = self._search_google_scholar(author_name)

    # Step 2: Parse and display options
    for i, title in enumerate(paper_titles, 1):
        print(f"{i}. {title}")

    # Step 3: Get user choice
    choice = input("Enter your choice: ")

    # Step 4: Analyze selected paper
    analysis_result = self._analyze_paper(selected_url)
```

### Error Handling Strategy

```python
try:
    # Attempt operation
    result = self.agent_executor.invoke({"input": query})
    return {"status": "success", "findings": result}
except Exception as e:
    return {"status": "failed", "error": str(e)}
```

**Best Practice:** Always return structured responses so the calling code knows what happened.

---

## üìä **Module 7: Content Extraction Techniques**

### Multi-Strategy Content Extraction

```python
content_selectors = [
    '.ltx_abstract',  # arXiv papers
    '#abstract',      # Journal papers
    '.abstract',      # Generic abstracts
    'article p',      # Article paragraphs
    'p'               # Fallback: any paragraphs
]
```

**Why Multiple Selectors?** Different websites structure content differently. We try specific selectors first, then fall back to more general ones.

### Content Quality Control

```python
for element in elements[:5]:  # Only first 5 elements
    text = element.inner_text().strip()
    if len(text) > 50:  # Only substantial content
        extracted_content += f"{text}\n\n"

return extracted_content[:1500]  # Limit total length
```

**Performance Tip:** Limit content extraction to prevent overwhelming the AI and reduce processing time.

---

## üéØ **Module 8: Demo Modes and Use Cases**

### 1. Single Research Demo

```python
def demo_research_agent():
    researcher_name = input("Enter researcher name: ")
    results = agent.research_papers_interactive(researcher_name)
```

**Use Case:** One-off research for personal learning

### 2. Interactive Research Mode

```python
def interactive_research_mode():
    while True:
        researcher_name = input("Enter researcher name (or 'quit'): ")
        if researcher_name.lower() == 'quit':
            break
        # Process research...
```

**Use Case:** Extended research sessions, comparing multiple researchers

### 3. Lecture Demo Mode

```python
def lecture_demo_mode():
    print("Ask your audience: 'Which AI researcher should we investigate?'")
    researcher_name = input("Enter audience suggestion: ")
    # Interactive demo with audience participation prompts
```

**Use Case:** Educational demonstrations, conference presentations

---

## üîß **Module 9: Advanced Features and Customization**

### Fallback Search Strategy

```python
def _search_google_scholar_broad(self, author_name: str):
    # If precise search fails, try broader search
    search_url = f'https://scholar.google.com/scholar?q={author_name}'
    # Less strict filtering for edge cases
```

### Timing and Performance Tracking

```python
start_time = time.time()
# ... do research work ...
elapsed = time.time() - start_time
return {"research_time": elapsed}
```

### Status Reporting

```python
return {
    "findings": final_results,
    "research_time": elapsed,
    "status": "research_complete"  # or "no_papers_found", "research_failed"
}
```

---

## üöÄ **Module 10: Running and Deployment**

### Prerequisites Installation

```bash
pip install langchain playwright ollama
playwright install chromium
ollama pull llama3.2
```

### Running the System

```python
if __name__ == "__main__":
    print("Choose your mode:")
    print("1. Single Research Demo")
    print("2. Interactive Research Mode")
    print("3. Lecture Demo Mode")

    choice = input("Select mode (1/2/3): ")
    # Route to appropriate demo function
```

---

## üéì **Final Project: Extending the Agent**

### Challenge 1: Add More Tools

Try adding these tools:

- **Conference Paper Search** - Search specific conferences
- **Citation Count Tool** - Get citation metrics
- **PDF Downloader** - Download papers locally

### Challenge 2: Improve Analysis

- **Multi-paper Comparison** - Compare papers side by side
- **Trend Analysis** - Identify research trends over time
- **Collaboration Networks** - Find researcher connections

### Challenge 3: Better User Experience

- **Web Interface** - Build a Flask/FastAPI frontend
- **Export Features** - Save results to PDF/Excel
- **Bookmark System** - Save interesting papers

---

## üìù **Key Takeaways**

1. **Agent Architecture:** LLM + Tools + Reasoning = Powerful automation
2. **Web Scraping:** Use robust tools like Playwright for dynamic content
3. **Local AI:** Ollama provides privacy and cost benefits
4. **Error Handling:** Always plan for failures and edge cases
5. **User Experience:** Interactive flows make tools more engaging
6. **Modularity:** Well-structured code is easier to extend and maintain

**Remember:** This is just the beginning! The real power comes from customizing and extending this foundation for your specific research needs.

---

## üîó **Next Steps**

- Experiment with different Ollama models
- Try scraping other academic databases
- Build domain-specific research agents
- Integrate with reference management tools

Happy coding! üéâ
